/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => WeatherPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var WEATHER_VIEW_TYPE = "tenki";
var DEFAULT_SETTINGS = {
  apiKey: "",
  unit: "celsius",
  // 30 minutes expressed in seconds
  refreshInterval: 30 * 60,
  location: ""
};
var MIN_REFRESH_SECONDS = 30 * 60;
var WeatherPlugin = class extends import_obsidian.Plugin {
  async onload() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
    this.settings.refreshInterval = Math.max(
      MIN_REFRESH_SECONDS,
      this.settings.refreshInterval || MIN_REFRESH_SECONDS
    );
    this.registerView(
      WEATHER_VIEW_TYPE,
      (leaf) => this.view = new WeatherView(leaf, this)
    );
    this.addCommand({
      id: "open",
      name: "open",
      callback: this.onShow.bind(this)
    });
    this.addCommand({
      id: "refresh",
      name: "Refresh",
      callback: () => {
        if (!this.view) {
          new import_obsidian.Notice("Open Tenki before refreshing");
          void this.initView();
          return;
        }
        this.view.refreshWeather();
      }
    });
    this.app.workspace.onLayoutReady(async () => {
      await this.initView();
    });
    this.addSettingTab(new WeatherSettingTab(this.app, this));
  }
  onShow() {
    this.initView();
  }
  async initView() {
    var _a;
    const existingLeaves = this.app.workspace.getLeavesOfType(
      WEATHER_VIEW_TYPE
    );
    if (existingLeaves.length) {
      const view = existingLeaves[0].view;
      this.view = view;
      return;
    }
    const leaf = (_a = this.app.workspace.getRightLeaf(false)) != null ? _a : this.app.workspace.getRightLeaf(true);
    if (!leaf) return;
    await leaf.setViewState({ type: WEATHER_VIEW_TYPE });
    this.app.workspace.revealLeaf(leaf);
    this.view = leaf.view;
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var WeatherView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.refreshIntervalId = null;
    this.lastErrorNoticeAt = null;
    this.plugin = plugin;
  }
  async onOpen() {
    await this.displayTemperature();
    this.startRefreshTimer();
  }
  refreshWeather() {
    this.displayTemperature();
    this.startRefreshTimer();
    new import_obsidian.Notice("Tenki updated");
  }
  onClose() {
    this.clearRefreshTimer();
    return super.onClose();
  }
  startRefreshTimer() {
    this.clearRefreshTimer();
    const refreshMs = Math.max(
      MIN_REFRESH_SECONDS,
      this.plugin.settings.refreshInterval
    );
    this.refreshIntervalId = window.setInterval(
      () => this.displayTemperature(),
      refreshMs * 1e3
    );
    this.registerInterval(this.refreshIntervalId);
  }
  clearRefreshTimer() {
    if (this.refreshIntervalId !== null) {
      window.clearInterval(this.refreshIntervalId);
      this.refreshIntervalId = null;
    }
  }
  restartRefreshTimer() {
    this.startRefreshTimer();
  }
  getViewType() {
    return WEATHER_VIEW_TYPE;
  }
  getDisplayText() {
    return "Tenki";
  }
  // Return the icon for the view
  getIcon() {
    return "sun";
  }
  async fetchWeatherData() {
    const { apiKey, location } = this.plugin.settings;
    if (!apiKey || !location) {
      throw new Error("Missing API key or location");
    }
    const WEATHER_API_URL = `https://api.weatherapi.com/v1/forecast.json?key=${encodeURIComponent(
      apiKey
    )}&q=${encodeURIComponent(location)}&days=3&aqi=yes`;
    const response = await (0, import_obsidian.requestUrl)({
      url: WEATHER_API_URL,
      method: "GET"
    });
    if (response.status >= 400) {
      throw new Error(`Weather API error ${response.status}`);
    }
    const weatherData = response.json;
    return weatherData;
  }
  async displayTemperature() {
    if (!this.plugin.settings.apiKey || !this.plugin.settings.location) {
      this.showErrorNotice("Set API key and location to load Tenki");
      return;
    }
    try {
      const weatherData = await this.fetchWeatherData();
      const weatherWidget = this.createWeatherWidget(weatherData);
      this.containerEl.empty();
      this.containerEl.appendChild(weatherWidget);
    } catch (error) {
      console.error("Failed to fetch weather data", error);
      this.showErrorNotice(
        "Tenki could not fetch weather. Check network, API key, and location."
      );
    }
  }
  showErrorNotice(message) {
    const now = Date.now();
    if (this.lastErrorNoticeAt === null || now - this.lastErrorNoticeAt > 6e4) {
      new import_obsidian.Notice(message);
      this.lastErrorNoticeAt = now;
    }
  }
  createWeatherWidget(weatherData) {
    const location = weatherData.location.name;
    const currentIcon = weatherData.current.condition.icon;
    const currentTemp = this.getTemperatureString(
      weatherData.current.temp_c,
      weatherData.current.temp_f
    );
    const feelsLikeTemp = this.getTemperatureString(
      weatherData.current.feelslike_c,
      weatherData.current.feelslike_f
    );
    const humidity = `${weatherData.current.humidity}%`;
    const uv = weatherData.current.uv.toString();
    const currentConditions = weatherData.current.condition.text;
    const forecastData = this.extractForecastData(weatherData.forecast);
    const lastUpdated = weatherData.current.last_updated;
    const weatherContainer = document.createElement("div");
    weatherContainer.className = "weather-container";
    const refreshButton = weatherContainer.createDiv(
      "tenki-refresh-button"
    );
    refreshButton.onclick = this.refreshWeather.bind(this);
    refreshButton.setAttribute("data-app-id", "tenki");
    new import_obsidian.ExtraButtonComponent(refreshButton).setIcon("refresh-ccw").setTooltip("Refresh", { placement: "top" });
    const locationDiv = document.createElement("div");
    locationDiv.className = "location";
    locationDiv.textContent = location;
    weatherContainer.appendChild(locationDiv);
    const currentContainer = document.createElement("div");
    currentContainer.className = "current-container";
    weatherContainer.appendChild(currentContainer);
    const currentIconImg = document.createElement("img");
    currentIconImg.className = "current-icon";
    currentIconImg.src = `https:${currentIcon}`;
    currentIconImg.alt = "Weather Icon";
    currentContainer.appendChild(currentIconImg);
    const currentStatsContainer = document.createElement("div");
    currentStatsContainer.className = "current-stats-container";
    currentContainer.appendChild(currentStatsContainer);
    const currentTempContainer = document.createElement("div");
    currentTempContainer.className = "current-temp-container";
    currentStatsContainer.appendChild(currentTempContainer);
    const currentTempDiv = document.createElement("div");
    currentTempDiv.className = "current-temp";
    currentTempDiv.textContent = currentTemp;
    currentTempContainer.appendChild(currentTempDiv);
    const feelsLikeTempDiv = document.createElement("div");
    feelsLikeTempDiv.className = "current-feelslike";
    feelsLikeTempDiv.textContent = feelsLikeTemp;
    currentTempContainer.appendChild(feelsLikeTempDiv);
    const humidityDiv = document.createElement("div");
    humidityDiv.className = "current-humidity";
    humidityDiv.textContent = "Humidity: ";
    currentStatsContainer.appendChild(humidityDiv);
    const humidityValueDiv = document.createElement("div");
    humidityValueDiv.className = "current-humidity-value";
    humidityValueDiv.textContent = humidity;
    humidityDiv.appendChild(humidityValueDiv);
    const uvDiv = document.createElement("div");
    uvDiv.className = "current-uv";
    uvDiv.textContent = "UV: ";
    currentStatsContainer.appendChild(uvDiv);
    const uvValueDiv = document.createElement("div");
    uvValueDiv.className = "current-uv-value";
    uvValueDiv.textContent = uv;
    uvDiv.appendChild(uvValueDiv);
    const aqDiv = document.createElement("div");
    aqDiv.className = "current-aq";
    if (weatherData.current.air_quality && weatherData.current.air_quality["us-epa-index"] !== void 0 && weatherData.current.air_quality["us-epa-index"] !== null) {
      const aq = String(
        weatherData.current.air_quality["us-epa-index"]
      );
      const aqText = document.createElement("span");
      aqText.textContent = "AQ: ";
      aqDiv.appendChild(aqText);
      const aqValueDiv = document.createElement("div");
      aqValueDiv.className = "current-aq-value";
      aqValueDiv.textContent = aq;
      const aqIconDiv = document.createElement("div");
      aqIconDiv.className = "current-aq-icon";
      const aqIcon = this.createIcon(aq);
      aqIconDiv.appendChild(aqIcon);
      aqDiv.appendChild(aqValueDiv);
      aqDiv.appendChild(aqIconDiv);
    }
    currentStatsContainer.appendChild(aqDiv);
    const currentConditionsDiv = document.createElement("div");
    currentConditionsDiv.className = "current-conditions";
    currentConditionsDiv.textContent = currentConditions;
    weatherContainer.appendChild(currentConditionsDiv);
    const forecastContainer = document.createElement("div");
    forecastContainer.className = "forecast-container";
    weatherContainer.appendChild(forecastContainer);
    forecastData.forEach((forecast) => {
      const forecastDayContainer = document.createElement("div");
      forecastDayContainer.className = "forecast-day-container";
      forecastContainer.appendChild(forecastDayContainer);
      const forecastDayDiv = document.createElement("div");
      forecastDayDiv.className = "forecast-day";
      const forecastDate = new Date(forecast.day);
      const today = /* @__PURE__ */ new Date();
      const month = forecastDate.toLocaleString(void 0, {
        month: "short",
        timeZone: "UTC"
      });
      const day = forecastDate.getUTCDate().toString();
      const forecastDateFormatted = forecastDate.getUTCDate() === today.getUTCDate() && forecastDate.getUTCMonth() === today.getUTCMonth() && forecastDate.getUTCFullYear() === today.getUTCFullYear() ? "Today" : `${month} ${day}`;
      forecastDayDiv.textContent = forecastDateFormatted;
      forecastDayContainer.appendChild(forecastDayDiv);
      const forecastIconImg = document.createElement("img");
      forecastIconImg.className = "forecast-icon";
      forecastIconImg.src = `https:${forecast.icon}`;
      forecastIconImg.alt = "Weather Icon";
      forecastDayContainer.appendChild(forecastIconImg);
      const forecastRainDiv = document.createElement("div");
      forecastRainDiv.className = "forecast-rain";
      forecastRainDiv.textContent = forecast.rain;
      forecastDayContainer.appendChild(forecastRainDiv);
      const tooltip = document.createElement("div");
      tooltip.className = "forecast-tooltip";
      let tooltipText = "";
      if (this.plugin.settings.unit === "celsius") {
        tooltipText = `${forecast.minTempC}\xB0C ${forecast.maxTempC}\xB0C`;
      } else {
        tooltipText = `${forecast.minTempF}\xB0F ${forecast.maxTempF}\xB0F`;
      }
      tooltipText += `
Sunrise: ${forecast.sunrise}
Sunset: ${forecast.sunset}`;
      tooltip.textContent = tooltipText;
      forecastDayContainer.appendChild(tooltip);
      forecastDayContainer.addEventListener("mouseover", () => {
        tooltip.style.visibility = "visible";
      });
      forecastDayContainer.addEventListener("mouseout", () => {
        tooltip.style.visibility = "hidden";
      });
    });
    const lastUpdatedDiv = document.createElement("div");
    lastUpdatedDiv.className = "last-updated";
    lastUpdatedDiv.textContent = "Source Updated: " + lastUpdated;
    weatherContainer.appendChild(lastUpdatedDiv);
    return weatherContainer;
  }
  getTemperatureString(celsius, fahrenheit) {
    if (this.plugin.settings.unit === "celsius") {
      return `${celsius}\xB0C`;
    } else {
      return `${fahrenheit}\xB0F`;
    }
  }
  extractForecastData(forecast) {
    if (!forecast) return [];
    return forecast.forecastday.map((forecastDay) => ({
      day: forecastDay.date,
      icon: forecastDay.day.condition.icon,
      rain: `${forecastDay.day.daily_chance_of_rain}%`,
      minTempC: `${forecastDay.day.mintemp_c}`,
      maxTempC: `${forecastDay.day.maxtemp_c}`,
      minTempF: `${forecastDay.day.mintemp_f}`,
      maxTempF: `${forecastDay.day.maxtemp_f}`,
      sunrise: forecastDay.astro.sunrise,
      sunset: forecastDay.astro.sunset
    }));
  }
  createIcon(iconType) {
    const icon = document.createElement("span");
    icon.className = "weather-icon";
    switch (iconType) {
      case "1":
        icon.textContent = "\u{1F60A}";
        break;
      case "2":
        icon.textContent = "\u{1F610}";
        break;
      case "3":
        icon.textContent = "\u{1F637}";
        break;
      case "4":
        icon.textContent = "\u{1F637}";
        break;
      case "5":
        icon.textContent = "\u{1F628}";
        break;
      case "6":
        icon.textContent = "\u2620\uFE0F";
        break;
      default:
        icon.textContent = "";
    }
    return icon;
  }
};
var WeatherSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    if (!plugin) {
      throw new Error("Plugin is undefined");
    }
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Tenki" });
    new import_obsidian.Setting(containerEl).setName("API Key").setDesc(
      createFragment((fragment) => {
        fragment.append(
          "Enter your API Key",
          fragment.createEl("br"),
          fragment.createEl("a", {
            text: "Get your free key here:",
            href: "https://www.weatherapi.com/"
          })
        );
      })
    ).addText(
      (text) => text.setPlaceholder("Enter API key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
        var _a;
        this.plugin.settings.apiKey = value.trim();
        await this.plugin.saveSettings();
        await ((_a = this.plugin.view) == null ? void 0 : _a.displayTemperature());
      })
    );
    new import_obsidian.Setting(containerEl).setName("Location").setDesc("Enter your location").addText(
      (text) => text.setPlaceholder("Enter your location").setValue(this.plugin.settings.location).onChange(
        (0, import_obsidian.debounce)(async (value) => {
          var _a;
          const trimmed = value.trim();
          this.plugin.settings.location = trimmed;
          await this.plugin.saveSettings();
          if (!trimmed) return;
          await ((_a = this.plugin.view) == null ? void 0 : _a.displayTemperature());
        }, 1500)
      )
    );
    new import_obsidian.Setting(containerEl).setName("Unit").setDesc("Select the unit for temperature").addDropdown(
      (dropdown) => dropdown.addOption("celsius", "Celsius").addOption("fahrenheit", "Fahrenheit").setValue(this.plugin.settings.unit).onChange(async (value) => {
        this.plugin.settings.unit = value;
        await this.plugin.saveSettings();
        this.plugin.view.displayTemperature();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Refresh Interval").setDesc("Set the refresh interval in minutes").addText(
      (text) => text.setPlaceholder("Enter refresh interval").setValue(
        (this.plugin.settings.refreshInterval / 60).toString()
      ).onChange(async (value) => {
        var _a, _b;
        const minutes = parseInt(value.trim(), 10);
        if (!isNaN(minutes) && minutes > 0) {
          const clampedMinutes = Math.max(30, minutes);
          this.plugin.settings.refreshInterval = clampedMinutes * 60;
          await this.plugin.saveSettings();
          await ((_a = this.plugin.view) == null ? void 0 : _a.displayTemperature());
          (_b = this.plugin.view) == null ? void 0 : _b.restartRefreshTimer();
        }
      })
    );
    const div = containerEl.createEl("div", {
      cls: "recent-files-donation"
    });
    const donateText = document.createElement("div");
    donateText.className = "donate-text";
    const donateDescription = document.createElement("p");
    donateDescription.textContent = "If you find this plugin valuable and would like to support its development, please consider using the button below. Your contribution is greatly appreciated!";
    donateText.appendChild(donateDescription);
    const donateLink = document.createElement("a");
    donateLink.href = "https://www.buymeacoffee.com/mstam30561";
    donateLink.target = "_blank";
    function rotateColorRandomly(element) {
      const rotationDegrees = Math.floor(Math.random() * 8 + 1) * 45;
      element.style.filter = `hue-rotate(${rotationDegrees}deg)`;
    }
    const donateImage = document.createElement("img");
    donateImage.src = "https://cdn.buymeacoffee.com/buttons/v2/default-blue.png";
    donateImage.alt = "Buy Me A Coffee";
    rotateColorRandomly(donateImage);
    donateImage.classList.add("donate-img");
    donateLink.appendChild(donateImage);
    donateText.appendChild(donateLink);
    div.appendChild(donateText);
  }
};

/* nosourcemap */